import numpy as np
import statsmodels.api as sm
from tqdm import tqdm


def alpha_beta(N_m, M, mu_alpha = 1., var_alpha = 0., rho_alpha = 0., mu_beta = 2., var_beta = 0., rho_beta = 0.):
    '''
    Return coefficients that have certain mean, variance and within-cluster correlation
    alpha is the intercept and beta is the coefficient of W
    
    Parameters:
    N_m (int): Cluster size
    M (int): Number of clusters
    mu_alpha (float): Mean of alpha
    var_alpha (float): Variance of alpha
    rho_alpha (float): Within-cluster correlation of alpha
    mu_beta (float): Mean of beta
    var_beta (float): Variance of beta
    rho_beta (float): Within-cluster correlation of beta
    
    Returns:
    list of arrays: Values of alpha and beta
    '''
    
    N = N_m * M
    
    if var_alpha != 0.:
        var_mu = rho_alpha * var_alpha
        var_nu = (1 - rho_alpha) * var_alpha
        mu = np.random.normal(loc = 0., scale = np.sqrt(var_mu), size = M)
        mu = np.repeat(mu, N_m)
        nu = np.random.normal(loc = 0., scale = np.sqrt(var_nu), size = N)
        alpha = (mu_alpha + mu + nu).reshape(-1, 1)
    
    elif var_alpha == 0.:
        alpha = np.ones([N, 1]) * mu_alpha
    
    if var_beta != 0.:
        var_mu = rho_beta * var_beta
        var_nu = (1 - rho_beta) * var_beta
        mu = np.random.normal(loc = 0., scale = np.sqrt(var_mu), size = M)
        mu = np.repeat(mu, N_m)
        nu = np.random.normal(loc = 0., scale = np.sqrt(var_nu), size = N)
        beta = (mu_beta + mu + nu).reshape(-1, 1)
    
    elif var_beta == 0.:
        beta = np.ones([N, 1]) * mu_beta
    
    return alpha, beta


def generate(N_m, M, alpha, beta, mu_W = 2., var_W = 1., rho_W = 0., var_u = 1., rho_u = 0.):
    '''
    Generate variables for regression
    
    Parameters:
    N_m (int): Cluster size
    M (int): Number of clusters
    alpha (array): Values of alpha generated by alpha_beta()
    beta (array): Values of beta generated by alpha_beta()
    mu_W (float): Mean of covariate
    var_W (float): Variance of covariate
    rho_W (float): Within-cluster correlation of covariate
    var_u (float): Variance of error term
    rho_u (float): Within-cluster correlation of error term
    
    Returns:
    list of arrays: Values of Y (dependent variable), W (covariate), X (intercept and W) and C (cluster)
    '''
    
    N = N_m * M
    
    var_eta = rho_u * var_u
    var_epsilon = (1 - rho_u) * var_u
    eta = np.random.normal(loc = 0., scale = np.sqrt(var_eta), size = M)
    eta = np.repeat(eta, N_m)
    epsilon = np.random.normal(loc = 0., scale = np.sqrt(var_epsilon), size = N)
    
    var_zeta = rho_W * var_W
    var_xi = (1 - rho_W) * var_W
    zeta = np.random.normal(loc = mu_W, scale = np.sqrt(var_zeta), size = M)
    zeta = np.repeat(zeta, N_m)
    xi = np.random.normal(loc = 0., scale = np.sqrt(var_xi), size = N)
    
    W = (zeta + xi).reshape(-1, 1)
    u = (eta + epsilon).reshape(-1, 1)
    
    Y = alpha + beta * W + u
    
    X = np.concatenate((np.ones([N, 1]), W), axis = 1)
    C = np.repeat(range(0, M), N_m).reshape(-1, 1)
    
    return Y, W, X, C


def simulate(N_m, M, mu_alpha = 1., var_alpha = 0., rho_alpha = 0., mu_beta = 2., var_beta = 0., rho_beta = 0.,
             mu_W = 2., var_W = 1., rho_W = 0., var_u = 1., rho_u = 0., R = 3000, verbose = True, print_table = True):
    '''
    Simulate standard deviation and standard errors
    
    Parameters:
    N_m (int): Cluster size
    M (int): Number of clusters
    mu_alpha (float): Mean of alpha
    var_alpha (float): Variance of alpha
    rho_alpha (float): Within-cluster correlation of alpha
    mu_beta (float): Mean of beta
    var_beta (float): Variance of beta
    rho_beta (float): Within-cluster correlation of beta    
    mu_W (float): Mean of covariate
    var_W (float): Variance of covariate
    rho_W (float): Within-cluster correlation of covariate
    var_u (float): Variance of error term
    rho_u (float): Within-cluster correlation of error term
    R (int): Number of iterations
    verbose (bool): If True, progress of iterations will be shown
    print_table (bool): If True, results will be printed like tables in the paper
    
    Returns:
    - If print_table is True, the results in the tables will be returned
    - If print_table is False,
    list: simulated standard deviation (se_sim), heteroskedasticity-robust standard error (se_EHW),
          Liang-Zeger cluster-robust standard error (se_LZ) and relative performance parameter (lamb)
    '''
    
    N = N_m * M
    
    alpha, beta = alpha_beta(N_m, M, mu_alpha, var_alpha, rho_alpha, mu_beta, var_beta, rho_beta)
    
    betahats = []; std_EHWs = []; std_LZs = []
    
    if verbose == True: range_R = tqdm(range(R))
    else: range_R = range(R)
    
    for r in range_R:
        
        Y, W, X, C = generate(N_m, M, alpha, beta, mu_W, var_W, rho_W, var_u, rho_u)

        results1 = sm.OLS(Y, X).fit(cov_type = 'HC0')
        results2 = sm.OLS(Y, X).fit(cov_type = 'cluster', cov_kwds = {'groups': C, 'use_correction': False})
        betahat = results1.params[1]

        std_EHW = results1.bse[1]
        std_LZ = results2.bse[1]

        betahats += [betahat]
        std_EHWs += [std_EHW]
        std_LZs += [std_LZ]
    
    se_sim = np.std(betahats)
    se_EHW = np.mean(std_EHWs)
    se_LZ = np.mean(std_LZs)
    lamb = (se_sim**2 - se_EHW**2)/(se_LZ**2 - se_EHW**2)
    
    if print_table:
        print(f'std: {se_sim:.4f}, EHW: {se_EHW:.4f}, LZ: {se_LZ:.4f}')
        
    else:
        return se_sim, se_EHW, se_LZ, lamb
    
    